{"version":3,"sources":["../src/AuthService.js"],"names":["AuthService","config","testing","disableHttpsCheck","authConfig","issuer","clientId","redirectUri","_oktaAuth","OktaAuth","userAgent","packageInfo","name","version","_config","_pending","handleAuthentication","bind","updateAuthState","clearAuthState","emitAuthState","getAuthState","getUser","getIdToken","getAccessToken","login","logout","_convertLogoutPathToOptions","redirect","emit","on","tokenManager","token","parseFromUrl","tokens","idToken","add","accessToken","authState","isAuthenticated","location","getFromUri","window","assign","error","state","DEFAULT_STATE","_authState","authStateUpdate","promise","resolve","get","claims","undefined","getUserInfo","fromUri","additionalParams","handleLogin","isPending","setFromUri","onAuthRequired","charAt","origin","postLogoutRedirectUri","options","signOut","params","responseType","scopes","getWithRedirect","href","sessionStorage","setItem","referrerKey","getItem","removeItem","event","callback","emitter","off","message"],"mappings":"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","file":"AuthService.js","sourcesContent":["/*\n * Copyright (c) 2017-Present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n */\nimport {\n  assertIssuer,\n  assertClientId,\n  assertRedirectUri,\n  buildConfigObject\n} from '@okta/configuration-validation';\nimport OktaAuth from '@okta/okta-auth-js';\n\nimport packageInfo from './packageInfo';\n\nclass AuthService {\n  constructor(config) {\n    const testing = {\n      // If the config is undefined, cast it to false\n      disableHttpsCheck: !!config.disableHttpsCheck\n    };\n\n    // normalize authJS config. In this SDK, we allow underscore on certain properties, but AuthJS consistently uses camel case.\n    const authConfig = buildConfigObject(config);\n    assertIssuer(authConfig.issuer, testing);\n    assertClientId(authConfig.clientId);\n    assertRedirectUri(authConfig.redirectUri);\n\n    this._oktaAuth = new OktaAuth(authConfig);\n    this._oktaAuth.userAgent = `${packageInfo.name}/${packageInfo.version} ${this._oktaAuth.userAgent}`;\n    this._config = authConfig; // use normalized config\n    this._pending = {}; // manage overlapping async calls \n\n    this.handleAuthentication = this.handleAuthentication.bind(this);\n    this.updateAuthState = this.updateAuthState.bind(this);\n    this.clearAuthState = this.clearAuthState.bind(this);\n    this.emitAuthState = this.emitAuthState.bind(this);\n    this.getAuthState = this.getAuthState.bind(this);\n    this.getUser = this.getUser.bind(this);\n    this.getIdToken = this.getIdToken.bind(this);\n    this.getAccessToken = this.getAccessToken.bind(this);\n    this.login = this.login.bind(this);\n    this.logout = this.logout.bind(this);\n    this._convertLogoutPathToOptions = this._convertLogoutPathToOptions.bind(this);\n    this.redirect = this.redirect.bind(this);\n    this.emit = this.emit.bind(this);\n    this.on = this.on.bind(this);\n\n    this.clearAuthState();\n\n    // Remove expired token or renew token if autoRenew is true\n    // This process will keep authState synced with states in tokenManager\n    this.on('expired', this.updateAuthState);\n  }\n\n  getTokenManager() {\n    return this._oktaAuth.tokenManager;\n  }\n\n  async handleAuthentication() {\n    if(this._pending.handleAuthentication) { \n      // Don't trigger second round\n      return null;\n    }\n    try { \n      this._pending.handleAuthentication = true;\n      const {tokens} = await this._oktaAuth.token.parseFromUrl();\n\n      if (tokens.idToken) {\n        this._oktaAuth.tokenManager.add('idToken', tokens.idToken);\n      }\n      if (tokens.accessToken) {\n        this._oktaAuth.tokenManager.add('accessToken', tokens.accessToken);\n      }\n\n      await this.updateAuthState();\n      const authState = this.getAuthState();\n      if(authState.isAuthenticated) { \n        const location = this.getFromUri();\n        window.location.assign(location);\n      }\n      this._pending.handleAuthentication = null;\n    } catch(error) { \n      this._pending.handleAuthentication = null;\n      this.emitAuthState({ \n        isAuthenticated: false,\n        error,\n        idToken: null,\n        accessToken: null,\n      });\n    } \n    return;\n  }\n\n  clearAuthState(state={}) { \n    this.emitAuthState({ ...AuthService.DEFAULT_STATE, ...state });\n    return;\n  }\n\n  emitAuthState(state) { \n    this._authState = state;\n    this.emit('authStateChange', this.getAuthState());\n    return;\n  }\n\n  getAuthState() { \n    return this._authState;\n  }\n\n  async updateAuthState() {\n    // avoid concurrent updates\n    if( this._pending.authStateUpdate ) { \n      return this._pending.authStateUpdate.promise;\n    }\n\n    // create a promise to return in case of multiple parallel requests\n    this._pending.authStateUpdate = {};\n    this._pending.authStateUpdate.promise  = new Promise( (resolve) => {\n      // Promise can only resolve, any error is in the resolve value\n      // and uncaught exceptions make Front SDKs angry\n      this._pending.authStateUpdate.resolve = resolve;\n    });\n    // copy to return after emitAuthState has cleared the pending object\n    const authStateUpdate = this._pending.authStateUpdate;\n\n    try { \n      const accessToken = await this.getAccessToken();\n      const idToken = await this.getIdToken();\n\n      // Use external check, or default to isAuthenticated if either the access or id token exist\n      const isAuthenticated = this._config.isAuthenticated ? await this._config.isAuthenticated() : !! ( accessToken || idToken );\n\n      this._pending.authStateUpdate = null;\n      this.emitAuthState({ \n        isAuthenticated,\n        idToken,\n        accessToken,\n      });\n    } catch (error) { \n      this._pending.authStateUpdate = null;\n      this.emitAuthState({ \n        isAuthenticated: false,\n        error,\n        idToken: null,\n        accessToken: null,\n      });\n    } \n    authStateUpdate.resolve();\n    return authStateUpdate.promise;\n  }\n\n  async getUser() {\n    const accessToken = await this._oktaAuth.tokenManager.get('accessToken');\n    const idToken = await this._oktaAuth.tokenManager.get('idToken');\n    if (!accessToken || !idToken) { \n      return idToken ? idToken.claims : undefined;\n    }\n\n    return this._oktaAuth.token.getUserInfo();\n  }\n\n  async getIdToken() {\n    try {\n      const idToken = await this._oktaAuth.tokenManager.get('idToken');\n      return idToken.idToken;\n    } catch (err) {\n      // The user no longer has an existing SSO session in the browser.\n      // (OIDC error `login_required`)\n      // Ask the user to authenticate again.\n      return undefined;\n    }\n  }\n\n  async getAccessToken() {\n    try {\n      const accessToken = await this._oktaAuth.tokenManager.get('accessToken');\n      return accessToken.accessToken;\n    } catch (err) {\n      // The user no longer has an existing SSO session in the browser.\n      // (OIDC error `login_required`)\n      // Ask the user to authenticate again.\n      return undefined;\n    }\n  }\n\n  async login(fromUri, additionalParams) {\n    if(this._pending.handleLogin) { \n      // Don't trigger second round\n      return;\n    }\n\n    this._pending.handleLogin = true;\n    // Update UI pending state\n    this.emitAuthState({ ...this.getAuthState(), isPending: true });\n    // Save the current url before redirect\n    this.setFromUri(fromUri); // will save current location if fromUri is undefined\n    try {\n      if (this._config.onAuthRequired) {\n        return await this._config.onAuthRequired(this);\n      }\n      return await this.redirect(additionalParams);\n    } finally {\n      this._pending.handleLogin = null;\n    }\n  }\n\n  _convertLogoutPathToOptions(redirectUri) { \n    if (typeof redirectUri !== 'string') {\n      return redirectUri;\n    }\n    // If a relative path was passed, convert to absolute URI\n    if (redirectUri.charAt(0) === '/') {\n      redirectUri = window.location.origin + redirectUri;\n    }\n    return {\n      postLogoutRedirectUri: redirectUri,\n    };\n  }\n\n  async logout(options={}) {\n    options = this._convertLogoutPathToOptions(options);\n    await this._oktaAuth.signOut(options);\n    this.clearAuthState();\n  }\n\n  async redirect(additionalParams = {}) {\n    // normalize config object\n    let params = buildConfigObject(additionalParams);\n\n    // set defaults\n    params.responseType = params.responseType\n      || this._config.responseType\n      || ['id_token', 'token'];\n\n    params.scopes = params.scopes\n      || this._config.scopes\n      || ['openid', 'email', 'profile'];\n\n    return this._oktaAuth.token.getWithRedirect(params);\n  }\n\n  setFromUri(fromUri) {\n    // Use current location if fromUri was not passed\n    fromUri = fromUri || window.location.href;\n    // If a relative path was passed, convert to absolute URI\n    if (fromUri.charAt(0) === '/') {\n      fromUri = window.location.origin + fromUri;\n    }\n    sessionStorage.setItem( 'secureRouterReferrerPath', fromUri );\n  }\n\n  getFromUri() {\n    const referrerKey = 'secureRouterReferrerPath';\n    const location = sessionStorage.getItem(referrerKey) || window.location.origin;\n    sessionStorage.removeItem(referrerKey);\n    return location;\n  }\n\n  on( event, callback ) {\n    this._oktaAuth.emitter.on(event, callback, this._oktaAuth.emitter);\n    return () => {\n      this._oktaAuth.emitter.off(event, callback);\n    };\n  }\n\n  emit(event, message ) { \n    this._oktaAuth.emitter.emit(event, message);\n  }\n  \n}\n\nAuthService.DEFAULT_STATE = { \n  isPending: true,\n  isAuthenticated: null,\n  idToken: null,\n  accessToken: null,\n};\n\nexport default AuthService;\n"]}